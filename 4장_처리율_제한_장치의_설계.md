# 4장: 처리율 제한 장치의 설계
* 처리율 제한 장치는 클라이언트 사이드, 서버 사이드 둘다 가능
* 서버 사이드에서는 api 서버에 두거나 앞단에 미들웨어로 둘 수 있음
* 처리율 제한 조작 문제를 막고 api 서버는 비지니스 로직 처리에 집중할 수 있게 서버 사이드에 미들웨어로 둔다 가정

# 처리율 제한 알고리즘의 종류
* 토큰 버킷: 일정 시간마다 토큰이 채워지는 버킷. 남은 토큰이 없다면 요청 폐기
* 누적 버킷: 버퍼에 요청이 쌓이고 일정한 처리율로 처리됨. 버퍼 초과하는 요청은 폐기
* 고정 윈도우 카운터: 일정 시간 단위로 윈도우 존재. 윈도우 사이즈 초과하는 요청은 폐기
    * 토큰 버킷과 고정 윈도우 카운터 차이점: 둘은 일정 시간마다 개수 충전된다는 점에서 유사하다 생각했으나, 토큰 버킷은 버킷 사이즈에 여유를 두면 토큰이 쌓였을 때 약간의 버스트를 허용, 고정 윈도우는 일정 시간 단위로 윈도우 초기화되어 쌓이는 것 없음
* 이동 윈도우 로깅: 시간 단위로 윈도우 설정해서 들어온 요청들 로깅, 쌓인 로그가 윈도우 사이즈 넘어가면 요청을 처리하지는 않고 로그는 남김
    * 장점: 다른 방식들은 처리량 넘는 요청들을 폐기해서 실제 클라이언트가 얼마나 요청 부하를 주고 있는지 모니터링하지 않지만, 이동 윈도우 로깅은 처리된 요청이 아닌 '모든 요청'을 로그 남겨서 처리율 제한에 고려하기 때문에 DoS 같은 공격에 더 잘 대응
* 이동 윈도우 카운터: 이전 윈도우와 겹치는 비율을 토대로, (이전 윈도우 요청) * (겹치는 비율) + 현재 윈도우 요청을 이용해서 남은 처리량 판단

# 요청 처리 카운터 관리
* 처리율 제한 장치에서 카운터를 관리하기 위해 레디스를 주로 이용함(이유: 처리율 제한 장치 스케일 아웃, 장애 대응)
* 이때, 처리율 제한 장치가 여러 대인 상황에서 동일 카운터에 락을 통해 접근하면 성능 저하 발생. 해결책은 아래와 같음:
    * 루아 스크립트: 카운터를 get해서 값을 업데이트하는 과정을 하나의 원자성을 가지도록 함
    (락은 레디스 외부의 락 객체를 관리해야 하지만, 루아 스크립트는 레디스 내부에서 작업을 원자적으로 처리하므로 불필요한 락 획득/해제 오버헤드가 없음)
    * 레디스 정렬 집합 자료 구조: 일정 기간(윈도우에 해당) 범위에서의 요청을 슬라이딩 윈도우로 얻을 수 있음. 처리율 제한 장치와 레디스 간 전송 시간으로 실제 요청 시간과 레디스 도달 시간의 차이가 있을 수 있는데 실제 요청 시간을 기반으로 정렬 집합 이용하면 빠른 정렬/윈도우 관리가 가능

# 추가로 고려할 부분
* 여러 데이터 센터가 존재하는 경우, 처리율 제한 장치가 해당 데이터 센터들에 동기화된 결과를 주는 방법(책에 설명되지 않음)
* 처리율 제한은 연성인가, 경성인가
* 클라이언트 사이드에서 처리율 제한에 걸리지 않게 설계: 캐싱, 백오프 시간 서버에서 제공, 처리율 설정 체크
* 처리율 제한 모니터링을 통해 처리율 제한 알고리즘과 규칙(토큰 개수, 처리 속도 설정이 적합한가) 튜닝
* 처리율 제한 어느 계층에서 일어날건지: 애플리케이션(7계층) or 트랜스포트(4계층) 비교